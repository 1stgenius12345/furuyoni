
#include "Share.fx"

/*
int : 정수
float : 실수
float2 ~ 4 : 2, 3, 4차원 벡터(float타입)
int2 ~ 4 : 2, 3, 4차원 벡터(int타입)
matrix : 4x4 행렬
float3x3 : 3x3 행렬 float타입
*/


struct VS_INPUT_COLOR
{
	// : 뒤에 Semantic 을 작성한다.
	// POSITION 레지스터에 있는 값을 얻어오겠다는 의미이다.
	// 뒤에는 레지스터 번호가 붙을 수 있다. POSITION1 이런식으로 작성이 가능하다.
	// 안붙여줄 경우에는 0번이 자동으로 지정이 된다.
	float3  Pos : POSITION;
	float4  Color : COLOR;
};

struct VS_OUTPUT_COLOR
{
	// SV 가 붙으면 System Value 이다.
	// 이 변수들은 Shader 코드에서 리턴용으로만 사용이 되고 연산용으로 사용이 불가능하다.
	// 투영 공간으로 변환된 정점을 SV_POSITION 레지스터에 넣어놓으면 PixelShader가 동작되기 전에
	// 화면공간으로의 변환이 일어나게 된다.
	float4  Pos : SV_POSITION;
	float4  Color : COLOR;
	float2	UV	: TEXCOORD;
};

float2 ComputeAnimation2DUV(float2 UV)
{
	if (g_Animation2DEnable == 0)
		return UV;

	if (g_Animation2DType == Animation2DFrame ||
		g_Animation2DType == Animation2DArray)
		return UV;

	float2	ResultUV;

	if (UV.x <= 0.f)
		ResultUV.x = g_vAnimation2DStartUV.x;

	else
		ResultUV.x = g_vAnimation2DEndUV.x;

	if (UV.y <= 0.f)
		ResultUV.y = g_vAnimation2DStartUV.y;

	else
		ResultUV.y = g_vAnimation2DEndUV.y;

	return ResultUV;
}

VS_OUTPUT_COLOR Standard2DColorVS(VS_INPUT_COLOR input)
{
	VS_OUTPUT_COLOR output = (VS_OUTPUT_COLOR)0;

	float3  Pos = input.Pos - g_vPivot * g_vMeshSize;

	// output.Pos 의 x, y, z 에는 input.Pos의 x, y, z 가 들어가고 w에는 1.f 이 들어가게 된다.
	output.Pos = mul(float4(Pos, 1.f), g_matWVP);
	output.Color = input.Color;

	return output;
}


PS_OUTPUT_SINGLE Standard2DColorPS(VS_OUTPUT_COLOR input)
{
	PS_OUTPUT_SINGLE    output = (PS_OUTPUT_SINGLE)0;

	float4	Color = input.Color * g_vMtrlBaseColor + g_vMtrlEmissiveColor;

	output.Color = Color;

	return output;
}

struct VS_INPUT_UV
{
	// : 뒤에 Semantic 을 작성한다.
	// POSITION 레지스터에 있는 값을 얻어오겠다는 의미이다.
	// 뒤에는 레지스터 번호가 붙을 수 있다. POSITION1 이런식으로 작성이 가능하다.
	// 안붙여줄 경우에는 0번이 자동으로 지정이 된다.
	float3  Pos : POSITION;
	float2  UV : TEXCOORD;
};

struct VS_OUTPUT_UV
{
	// SV 가 붙으면 System Value 이다.
	// 이 변수들은 Shader 코드에서 리턴용으로만 사용이 되고 연산용으로 사용이 불가능하다.
	// 투영 공간으로 변환된 정점을 SV_POSITION 레지스터에 넣어놓으면 PixelShader가 동작되기 전에
	// 화면공간으로의 변환이 일어나게 된다.
	float4  Pos : SV_POSITION;
	float2  UV : TEXCOORD;
	float4	ProjPos : POSITION;
};

VS_OUTPUT_UV Standard2DTextureVS(VS_INPUT_UV input)
{
	VS_OUTPUT_UV output = (VS_OUTPUT_UV)0;

	float3  Pos = input.Pos - g_vPivot * g_vMeshSize;

	// output.Pos 의 x, y, z 에는 input.Pos의 x, y, z 가 들어가고 w에는 1.f 이 들어가게 된다.
	output.ProjPos = mul(float4(Pos, 1.f), g_matWVP);
	output.Pos = output.ProjPos;
	output.UV = ComputeAnimation2DUV(input.UV);

	return output;
}


PS_OUTPUT_SINGLE Standard2DTexturePS(VS_OUTPUT_UV input)
{
	PS_OUTPUT_SINGLE    output = (PS_OUTPUT_SINGLE)0;

	float4  BaseColor = g_BaseTexture.Sample(g_AnisotropicSmp, input.UV);
	float4	EmissiveColor = g_EmissiveTexture.Sample(g_AnisotropicSmp, input.UV);
	
	float4 color1 = g_DistortionFilterTex.Sample(g_AnisotropicSmp, input.UV);


	float4	result = (float4)0.f;

	result.rgb = BaseColor.rgb * (g_vMtrlBaseColor.rgb) * (color1.rgb/0.5f) + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb ;

	result.a = BaseColor.a * g_MtrlOpacity / (color1.a);

	result = PaperBurn2D(result, input.UV);

	result = Distortion(result, input.UV, input.ProjPos);

	output.Color = result;

	return output;
}



struct VS_INPUT2_UV
{
	// : 뒤에 Semantic 을 작성한다.
	// POSITION 레지스터에 있는 값을 얻어오겠다는 의미이다.
	// 뒤에는 레지스터 번호가 붙을 수 있다. POSITION1 이런식으로 작성이 가능하다.
	// 안붙여줄 경우에는 0번이 자동으로 지정이 된다.
	float3  Pos : POSITION;
	float2  UV : TEXCOORD;
};

struct VS_OUTPUT2_UV
{
	// SV 가 붙으면 System Value 이다.
	// 이 변수들은 Shader 코드에서 리턴용으로만 사용이 되고 연산용으로 사용이 불가능하다.
	// 투영 공간으로 변환된 정점을 SV_POSITION 레지스터에 넣어놓으면 PixelShader가 동작되기 전에
	// 화면공간으로의 변환이 일어나게 된다.
	float4  Pos : SV_POSITION;
	float2  UV : TEXCOORD;
	float4	ProjPos : POSITION;
	float   clip : SV_ClipDistance0;
	float   clip1 : SV_ClipDistance1;
};

VS_OUTPUT2_UV Standard2DTitleVS(VS_INPUT2_UV input)
{
	VS_OUTPUT2_UV output = (VS_OUTPUT2_UV)0;

	float3  Pos = input.Pos - g_vPivot * g_vMeshSize;
	
	float4  clip = float4(0.f, 1.f, 0.f, input.Pos.y/2.f-0.1f);
	float4  clip1 = float4(0.f, -1.f, 0.f, input.Pos.y);
	//	float4  clip1 = float4(0.f, -0.2f, 0.f, 0.f);
		//float4  clip1 = float4()
		// output.Pos 의 x, y, z 에는 input.Pos의 x, y, z 가 들어가고 w에는 1.f 이 들어가게 된다.
	output.ProjPos = mul(float4(Pos, 1.f), g_matWVP);
	//output.
	output.Pos = output.ProjPos;
	output.UV = ComputeAnimation2DUV(input.UV);
	output.clip = dot(mul(float4(Pos, 1.f), g_matWVP), clip);
	output.clip1 = dot(mul(float4(Pos, 1.f), g_matWVP), clip1);
	return output;
}


PS_OUTPUT_SINGLE Standard2DTitlePS(VS_OUTPUT2_UV input)
{
	PS_OUTPUT_SINGLE    output = (PS_OUTPUT_SINGLE)0;

	float4  BaseColor = g_BaseTexture.Sample(g_AnisotropicSmp, input.UV);
	float4	EmissiveColor = g_EmissiveTexture.Sample(g_AnisotropicSmp, input.UV);

	float4	result = (float4)0.f;

	//result.rgb = BaseColor.rgb * g_vMtrlBaseColor.rgb *0.5f + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb;
	result.rgb = BaseColor.rgb * g_vMtrlBaseColor.rgb + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb;
	result.a = BaseColor.a * g_MtrlOpacity;


	output.Color = result;

	return output;
}


struct VS_INPUT3_UV
{
	// : 뒤에 Semantic 을 작성한다.
	// POSITION 레지스터에 있는 값을 얻어오겠다는 의미이다.
	// 뒤에는 레지스터 번호가 붙을 수 있다. POSITION1 이런식으로 작성이 가능하다.
	// 안붙여줄 경우에는 0번이 자동으로 지정이 된다.
	float3  Pos : POSITION;
	float2  UV : TEXCOORD;
};

struct VS_OUTPUT3_UV
{
	// SV 가 붙으면 System Value 이다.
	// 이 변수들은 Shader 코드에서 리턴용으로만 사용이 되고 연산용으로 사용이 불가능하다.
	// 투영 공간으로 변환된 정점을 SV_POSITION 레지스터에 넣어놓으면 PixelShader가 동작되기 전에
	// 화면공간으로의 변환이 일어나게 된다.
	float4  Pos : SV_POSITION;
	float2  UV : TEXCOORD;
	float4	ProjPos : POSITION;
	float   clip : SV_ClipDistance0;
	float   clip1 : SV_ClipDistance1;
};

VS_OUTPUT3_UV Standard2DLogVS(VS_INPUT3_UV input)
{
	VS_OUTPUT3_UV output = (VS_OUTPUT3_UV)0;

	float3  Pos = input.Pos - g_vPivot * g_vMeshSize;

	float4  clip = float4(0.f, 1.f, 0.f, 0.8f);
	float4  clip1 = float4(0.f, -1.f, 0.f, 0.8f);
	//	float4  clip1 = float4(0.f, -0.2f, 0.f, 0.f);
		//float4  clip1 = float4()
		// output.Pos 의 x, y, z 에는 input.Pos의 x, y, z 가 들어가고 w에는 1.f 이 들어가게 된다.
	output.ProjPos = mul(float4(Pos, 1.f), g_matWVP);
	//output.
	output.Pos = output.ProjPos;
	output.UV = ComputeAnimation2DUV(input.UV);
	output.clip = dot(mul(float4(Pos, 1.f), g_matWVP), clip);
	output.clip1 = dot(mul(float4(Pos, 1.f), g_matWVP), clip1);
	return output;
}


PS_OUTPUT_SINGLE Standard2DLogPS(VS_OUTPUT3_UV input)
{
	PS_OUTPUT_SINGLE    output = (PS_OUTPUT_SINGLE)0;

	float4  BaseColor = g_BaseTexture.Sample(g_AnisotropicSmp, input.UV);
	float4	EmissiveColor = g_EmissiveTexture.Sample(g_AnisotropicSmp, input.UV);

	float4	result = (float4)0.f;

	//result.rgb = BaseColor.rgb * g_vMtrlBaseColor.rgb *0.5f + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb;
	result.rgb = BaseColor.rgb * g_vMtrlBaseColor.rgb + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb;
	result.a = BaseColor.a * g_MtrlOpacity;


	output.Color = result;

	return output;
}





struct VS_INPUT4_UV
{
	// : 뒤에 Semantic 을 작성한다.
	// POSITION 레지스터에 있는 값을 얻어오겠다는 의미이다.
	// 뒤에는 레지스터 번호가 붙을 수 있다. POSITION1 이런식으로 작성이 가능하다.
	// 안붙여줄 경우에는 0번이 자동으로 지정이 된다.
	float3  Pos : POSITION;
	float2  UV : TEXCOORD;
};

struct VS_OUTPUT4_UV
{
	// SV 가 붙으면 System Value 이다.
	// 이 변수들은 Shader 코드에서 리턴용으로만 사용이 되고 연산용으로 사용이 불가능하다.
	// 투영 공간으로 변환된 정점을 SV_POSITION 레지스터에 넣어놓으면 PixelShader가 동작되기 전에
	// 화면공간으로의 변환이 일어나게 된다.
	float4  Pos : SV_POSITION;
	float2  UV : TEXCOORD;
	float4	ProjPos : POSITION;
	float   clip : SV_ClipDistance0;
	float   clip1 : SV_ClipDistance1;
};

VS_OUTPUT3_UV Standard2DRangeVS(VS_INPUT4_UV input)
{
	VS_OUTPUT4_UV output = (VS_OUTPUT4_UV)0;

	float3  Pos = input.Pos - g_vPivot * g_vMeshSize;

	float4  clip = float4(0.f, 1.f, 0.f, 0.35f);
	float4  clip1 = float4(0.f, -1.f, 0.f, 0.80f);
	//	float4  clip1 = float4(0.f, -0.2f, 0.f, 0.f);
		//float4  clip1 = float4()
		// output.Pos 의 x, y, z 에는 input.Pos의 x, y, z 가 들어가고 w에는 1.f 이 들어가게 된다.
	output.ProjPos = mul(float4(Pos, 1.f), g_matWVP);
	//output.
	output.Pos = output.ProjPos;
	output.UV = ComputeAnimation2DUV(input.UV);
	output.clip = dot(mul(float4(Pos, 1.f), g_matWVP), clip);
	output.clip1 = dot(mul(float4(Pos, 1.f), g_matWVP), clip1);
	return output;
}


PS_OUTPUT_SINGLE Standard2DRangePS(VS_OUTPUT4_UV input)
{
	PS_OUTPUT_SINGLE    output = (PS_OUTPUT_SINGLE)0;

	float4  BaseColor = g_BaseTexture.Sample(g_AnisotropicSmp, input.UV);
	float4	EmissiveColor = g_EmissiveTexture.Sample(g_AnisotropicSmp, input.UV);

	float4	result = (float4)0.f;

	//result.rgb = BaseColor.rgb * g_vMtrlBaseColor.rgb *0.5f + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb;
	result.rgb = BaseColor.rgb * g_vMtrlBaseColor.rgb + EmissiveColor.rgb * g_vMtrlEmissiveColor.rgb;
	result.a = BaseColor.a * g_MtrlOpacity;


	output.Color = result;

	return output;
}
